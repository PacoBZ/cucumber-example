"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const protractor_1 = require("protractor");
let mask_fn = require('./mask').MASK_FN;
// Require looks-same casted with shim interface LooksSame typing.
let looksSame = require('looks-same');
/**
 * Compare a screenshot to a reference, or "golden" image.
 * Returns a Promise that resolves to whether or not the
 * screenshot is a match. If the UPDATE_SCREENSHOTS environment
 * variable is set, the promise resolves to true and the
 * golden image is updated.
 *
 * @param data The screenshot image data.
 * @param golden The path to the golden image to compare to.
 */
function compareScreenshot(data, golden) {
    return __awaiter(this, void 0, void 0, function* () {
        let screenshotPath = yield writeScreenshot(data);
        const update = process.env['UPDATE_GOLDENS'] == "1" ||
            process.env['UPDATE_GOLDENS'] === "true";
        if (update) {
            console.log('Updating reference images instead of comparing.');
            fs.writeFileSync(golden, fs.readFileSync(screenshotPath));
            return true;
        }
        else {
            return new Promise((resolve, reject) => {
                looksSame(screenshotPath, golden, { strict: false, tolerance: 2.5 }, (error, equal) => {
                    if (!equal) {
                        looksSame.createDiff({
                            reference: golden,
                            current: screenshotPath,
                            diff: 'diff.png',
                            highlightColor: '#ff00ff',
                        }, (error) => {
                            reject(`Screenshots do not match for ${golden}.`);
                        });
                    }
                    else {
                        resolve(true);
                    }
                });
            });
        }
    });
}
exports.compareScreenshot = compareScreenshot;
/**
 *  Write a screenshot to disk in a new temporary path.
 */
function writeScreenshot(data) {
    return __awaiter(this, void 0, void 0, function* () {
        const folder = fs.mkdtempSync(`${os.tmpdir()}${path.sep}`);
        let screenshotFile = path.join(folder, 'new.png');
        fs.writeFileSync(screenshotFile, data, 'base64');
        return screenshotFile;
    });
}
function addMask(el, color) {
    return __awaiter(this, void 0, void 0, function* () {
        let size = yield el.getSize();
        let location = yield el.getLocation();
        yield protractor_1.browser.executeScript(mask_fn, location.x, location.y, size.width, size.height, color);
    });
}
exports.addMask = addMask;
//# sourceMappingURL=screenshot_helper.js.map